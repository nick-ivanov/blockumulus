0x44cd5311810ef243bdd976bddffe72e914d14175f54267a7aa22923a4b8c65807c55bfbfa04bafc8bf7c3d5611d4a93aefee0dabca2f78c7d5547136b943f3861b
Signature valid: true
{
  status: '1',
  message: 'OK',
  result: [
    {
      SourceCode: 'pragma solidity ^0.4.17;\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title SafeMath\r\n' +
        ' * @dev Math operations with safety checks that throw on error\r\n' +
        ' */\r\n' +
        'library SafeMath {\r\n' +
        '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n' +
        '        if (a == 0) {\r\n' +
        '            return 0;\r\n' +
        '        }\r\n' +
        '        uint256 c = a * b;\r\n' +
        '        assert(c / a == b);\r\n' +
        '        return c;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n' +
        '        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n' +
        '        uint256 c = a / b;\r\n' +
        "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n" +
        '        return c;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n' +
        '        assert(b <= a);\r\n' +
        '        return a - b;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n' +
        '        uint256 c = a + b;\r\n' +
        '        assert(c >= a);\r\n' +
        '        return c;\r\n' +
        '    }\r\n' +
        '}\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title Ownable\r\n' +
        ' * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n' +
        ' * functions, this simplifies the implementation of "user permissions".\r\n' +
        ' */\r\n' +
        'contract Ownable {\r\n' +
        '    address public owner;\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n' +
        '      * account.\r\n' +
        '      */\r\n' +
        '    function Ownable() public {\r\n' +
        '        owner = msg.sender;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '      * @dev Throws if called by any account other than the owner.\r\n' +
        '      */\r\n' +
        '    modifier onlyOwner() {\r\n' +
        '        require(msg.sender == owner);\r\n' +
        '        _;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n' +
        '    * @param newOwner The address to transfer ownership to.\r\n' +
        '    */\r\n' +
        '    function transferOwnership(address newOwner) public onlyOwner {\r\n' +
        '        if (newOwner != address(0)) {\r\n' +
        '            owner = newOwner;\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '}\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title ERC20Basic\r\n' +
        ' * @dev Simpler version of ERC20 interface\r\n' +
        ' * @dev see https://github.com/ethereum/EIPs/issues/20\r\n' +
        ' */\r\n' +
        'contract ERC20Basic {\r\n' +
        '    uint public _totalSupply;\r\n' +
        '    function totalSupply() public constant returns (uint);\r\n' +
        '    function balanceOf(address who) public constant returns (uint);\r\n' +
        '    function transfer(address to, uint value) public;\r\n' +
        '    event Transfer(address indexed from, address indexed to, uint value);\r\n' +
        '}\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title ERC20 interface\r\n' +
        ' * @dev see https://github.com/ethereum/EIPs/issues/20\r\n' +
        ' */\r\n' +
        'contract ERC20 is ERC20Basic {\r\n' +
        '    function allowance(address owner, address spender) public constant returns (uint);\r\n' +
        '    function transferFrom(address from, address to, uint value) public;\r\n' +
        '    function approve(address spender, uint value) public;\r\n' +
        '    event Approval(address indexed owner, address indexed spender, uint value);\r\n' +
        '}\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title Basic token\r\n' +
        ' * @dev Basic version of StandardToken, with no allowances.\r\n' +
        ' */\r\n' +
        'contract BasicToken is Ownable, ERC20Basic {\r\n' +
        '    using SafeMath for uint;\r\n' +
        '\r\n' +
        '    mapping(address => uint) public balances;\r\n' +
        '\r\n' +
        '    // additional variables for use if transaction fees ever became necessary\r\n' +
        '    uint public basisPointsRate = 0;\r\n' +
        '    uint public maximumFee = 0;\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Fix for the ERC20 short address attack.\r\n' +
        '    */\r\n' +
        '    modifier onlyPayloadSize(uint size) {\r\n' +
        '        require(!(msg.data.length < size + 4));\r\n' +
        '        _;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev transfer token for a specified address\r\n' +
        '    * @param _to The address to transfer to.\r\n' +
        '    * @param _value The amount to be transferred.\r\n' +
        '    */\r\n' +
        '    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\r\n' +
        '        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n' +
        '        if (fee > maximumFee) {\r\n' +
        '            fee = maximumFee;\r\n' +
        '        }\r\n' +
        '        uint sendAmount = _value.sub(fee);\r\n' +
        '        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n' +
        '        balances[_to] = balances[_to].add(sendAmount);\r\n' +
        '        if (fee > 0) {\r\n' +
        '            balances[owner] = balances[owner].add(fee);\r\n' +
        '            Transfer(msg.sender, owner, fee);\r\n' +
        '        }\r\n' +
        '        Transfer(msg.sender, _to, sendAmount);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Gets the balance of the specified address.\r\n' +
        '    * @param _owner The address to query the the balance of.\r\n' +
        '    * @return An uint representing the amount owned by the passed address.\r\n' +
        '    */\r\n' +
        '    function balanceOf(address _owner) public constant returns (uint balance) {\r\n' +
        '        return balances[_owner];\r\n' +
        '    }\r\n' +
        '\r\n' +
        '}\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title Standard ERC20 token\r\n' +
        ' *\r\n' +
        ' * @dev Implementation of the basic standard token.\r\n' +
        ' * @dev https://github.com/ethereum/EIPs/issues/20\r\n' +
        ' * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n' +
        ' */\r\n' +
        'contract StandardToken is BasicToken, ERC20 {\r\n' +
        '\r\n' +
        '    mapping (address => mapping (address => uint)) public allowed;\r\n' +
        '\r\n' +
        '    uint public constant MAX_UINT = 2**256 - 1;\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Transfer tokens from one address to another\r\n' +
        '    * @param _from address The address which you want to send tokens from\r\n' +
        '    * @param _to address The address which you want to transfer to\r\n' +
        '    * @param _value uint the amount of tokens to be transferred\r\n' +
        '    */\r\n' +
        '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\r\n' +
        '        var _allowance = allowed[_from][msg.sender];\r\n' +
        '\r\n' +
        '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n' +
        '        // if (_value > _allowance) throw;\r\n' +
        '\r\n' +
        '        uint fee = (_value.mul(basisPointsRate)).div(10000);\r\n' +
        '        if (fee > maximumFee) {\r\n' +
        '            fee = maximumFee;\r\n' +
        '        }\r\n' +
        '        if (_allowance < MAX_UINT) {\r\n' +
        '            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n' +
        '        }\r\n' +
        '        uint sendAmount = _value.sub(fee);\r\n' +
        '        balances[_from] = balances[_from].sub(_value);\r\n' +
        '        balances[_to] = balances[_to].add(sendAmount);\r\n' +
        '        if (fee > 0) {\r\n' +
        '            balances[owner] = balances[owner].add(fee);\r\n' +
        '            Transfer(_from, owner, fee);\r\n' +
        '        }\r\n' +
        '        Transfer(_from, _to, sendAmount);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n' +
        '    * @param _spender The address which will spend the funds.\r\n' +
        '    * @param _value The amount of tokens to be spent.\r\n' +
        '    */\r\n' +
        '    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n' +
        '\r\n' +
        '        // To change the approve amount you first have to reduce the addresses`\r\n' +
        '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n' +
        '        //  already 0 to mitigate the race condition described here:\r\n' +
        '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n' +
        '        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\r\n' +
        '\r\n' +
        '        allowed[msg.sender][_spender] = _value;\r\n' +
        '        Approval(msg.sender, _spender, _value);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    /**\r\n' +
        '    * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n' +
        '    * @param _owner address The address which owns the funds.\r\n' +
        '    * @param _spender address The address which will spend the funds.\r\n' +
        '    * @return A uint specifying the amount of tokens still available for the spender.\r\n' +
        '    */\r\n' +
        '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n' +
        '        return allowed[_owner][_spender];\r\n' +
        '    }\r\n' +
        '\r\n' +
        '}\r\n' +
        '\r\n' +
        '\r\n' +
        '/**\r\n' +
        ' * @title Pausable\r\n' +
        ' * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n' +
        ' */\r\n' +
        'contract Pausable is Ownable {\r\n' +
        '  event Pause();\r\n' +
        '  event Unpause();\r\n' +
        '\r\n' +
        '  bool public paused = false;\r\n' +
        '\r\n' +
        '\r\n' +
        '  /**\r\n' +
        '   * @dev Modifier to make a function callable only when the contract is not paused.\r\n' +
        '   */\r\n' +
        '  modifier whenNotPaused() {\r\n' +
        '    require(!paused);\r\n' +
        '    _;\r\n' +
        '  }\r\n' +
        '\r\n' +
        '  /**\r\n' +
        '   * @dev Modifier to make a function callable only when the contract is paused.\r\n' +
        '   */\r\n' +
        '  modifier whenPaused() {\r\n' +
        '    require(paused);\r\n' +
        '    _;\r\n' +
        '  }\r\n' +
        '\r\n' +
        '  /**\r\n' +
        '   * @dev called by the owner to pause, triggers stopped state\r\n' +
        '   */\r\n' +
        '  function pause() onlyOwner whenNotPaused public {\r\n' +
        '    paused = true;\r\n' +
        '    Pause();\r\n' +
        '  }\r\n' +
        '\r\n' +
        '  /**\r\n' +
        '   * @dev called by the owner to unpause, returns to normal state\r\n' +
        '   */\r\n' +
        '  function unpause() onlyOwner whenPaused public {\r\n' +
        '    paused = false;\r\n' +
        '    Unpause();\r\n' +
        '  }\r\n' +
        '}\r\n' +
        '\r\n' +
        'contract BlackList is Ownable, BasicToken {\r\n' +
        '\r\n' +
        '    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////\r\n' +
        '    function getBlackListStatus(address _maker) external constant returns (bool) {\r\n' +
        '        return isBlackListed[_maker];\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function getOwner() external constant returns (address) {\r\n' +
        '        return owner;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    mapping (address => bool) public isBlackListed;\r\n' +
        '    \r\n' +
        '    function addBlackList (address _evilUser) public onlyOwner {\r\n' +
        '        isBlackListed[_evilUser] = true;\r\n' +
        '        AddedBlackList(_evilUser);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function removeBlackList (address _clearedUser) public onlyOwner {\r\n' +
        '        isBlackListed[_clearedUser] = false;\r\n' +
        '        RemovedBlackList(_clearedUser);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function destroyBlackFunds (address _blackListedUser) public onlyOwner {\r\n' +
        '        require(isBlackListed[_blackListedUser]);\r\n' +
        '        uint dirtyFunds = balanceOf(_blackListedUser);\r\n' +
        '        balances[_blackListedUser] = 0;\r\n' +
        '        _totalSupply -= dirtyFunds;\r\n' +
        '        DestroyedBlackFunds(_blackListedUser, dirtyFunds);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\r\n' +
        '\r\n' +
        '    event AddedBlackList(address _user);\r\n' +
        '\r\n' +
        '    event RemovedBlackList(address _user);\r\n' +
        '\r\n' +
        '}\r\n' +
        '\r\n' +
        'contract UpgradedStandardToken is StandardToken{\r\n' +
        '    // those methods are called by the legacy contract\r\n' +
        '    // and they must ensure msg.sender to be the contract address\r\n' +
        '    function transferByLegacy(address from, address to, uint value) public;\r\n' +
        '    function transferFromByLegacy(address sender, address from, address spender, uint value) public;\r\n' +
        '    function approveByLegacy(address from, address spender, uint value) public;\r\n' +
        '}\r\n' +
        '\r\n' +
        'contract TetherToken is Pausable, StandardToken, BlackList {\r\n' +
        '\r\n' +
        '    string public name;\r\n' +
        '    string public symbol;\r\n' +
        '    uint public decimals;\r\n' +
        '    address public upgradedAddress;\r\n' +
        '    bool public deprecated;\r\n' +
        '\r\n' +
        '    //  The contract can be initialized with a number of tokens\r\n' +
        '    //  All the tokens are deposited to the owner address\r\n' +
        '    //\r\n' +
        '    // @param _balance Initial supply of the contract\r\n' +
        '    // @param _name Token Name\r\n' +
        '    // @param _symbol Token symbol\r\n' +
        '    // @param _decimals Token decimals\r\n' +
        '    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\r\n' +
        '        _totalSupply = _initialSupply;\r\n' +
        '        name = _name;\r\n' +
        '        symbol = _symbol;\r\n' +
        '        decimals = _decimals;\r\n' +
        '        balances[owner] = _initialSupply;\r\n' +
        '        deprecated = false;\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n' +
        '    function transfer(address _to, uint _value) public whenNotPaused {\r\n' +
        '        require(!isBlackListed[msg.sender]);\r\n' +
        '        if (deprecated) {\r\n' +
        '            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);\r\n' +
        '        } else {\r\n' +
        '            return super.transfer(_to, _value);\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n' +
        '    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\r\n' +
        '        require(!isBlackListed[_from]);\r\n' +
        '        if (deprecated) {\r\n' +
        '            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\r\n' +
        '        } else {\r\n' +
        '            return super.transferFrom(_from, _to, _value);\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n' +
        '    function balanceOf(address who) public constant returns (uint) {\r\n' +
        '        if (deprecated) {\r\n' +
        '            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\r\n' +
        '        } else {\r\n' +
        '            return super.balanceOf(who);\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n' +
        '    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\r\n' +
        '        if (deprecated) {\r\n' +
        '            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\r\n' +
        '        } else {\r\n' +
        '            return super.approve(_spender, _value);\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Forward ERC20 methods to upgraded contract if this one is deprecated\r\n' +
        '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n' +
        '        if (deprecated) {\r\n' +
        '            return StandardToken(upgradedAddress).allowance(_owner, _spender);\r\n' +
        '        } else {\r\n' +
        '            return super.allowance(_owner, _spender);\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // deprecate current contract in favour of a new one\r\n' +
        '    function deprecate(address _upgradedAddress) public onlyOwner {\r\n' +
        '        deprecated = true;\r\n' +
        '        upgradedAddress = _upgradedAddress;\r\n' +
        '        Deprecate(_upgradedAddress);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // deprecate current contract if favour of a new one\r\n' +
        '    function totalSupply() public constant returns (uint) {\r\n' +
        '        if (deprecated) {\r\n' +
        '            return StandardToken(upgradedAddress).totalSupply();\r\n' +
        '        } else {\r\n' +
        '            return _totalSupply;\r\n' +
        '        }\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Issue a new amount of tokens\r\n' +
        '    // these tokens are deposited into the owner address\r\n' +
        '    //\r\n' +
        '    // @param _amount Number of tokens to be issued\r\n' +
        '    function issue(uint amount) public onlyOwner {\r\n' +
        '        require(_totalSupply + amount > _totalSupply);\r\n' +
        '        require(balances[owner] + amount > balances[owner]);\r\n' +
        '\r\n' +
        '        balances[owner] += amount;\r\n' +
        '        _totalSupply += amount;\r\n' +
        '        Issue(amount);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Redeem tokens.\r\n' +
        '    // These tokens are withdrawn from the owner address\r\n' +
        '    // if the balance must be enough to cover the redeem\r\n' +
        '    // or the call will fail.\r\n' +
        '    // @param _amount Number of tokens to be issued\r\n' +
        '    function redeem(uint amount) public onlyOwner {\r\n' +
        '        require(_totalSupply >= amount);\r\n' +
        '        require(balances[owner] >= amount);\r\n' +
        '\r\n' +
        '        _totalSupply -= amount;\r\n' +
        '        balances[owner] -= amount;\r\n' +
        '        Redeem(amount);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {\r\n' +
        '        // Ensure transparency by hardcoding limit beyond which fees can never be added\r\n' +
        '        require(newBasisPoints < 20);\r\n' +
        '        require(newMaxFee < 50);\r\n' +
        '\r\n' +
        '        basisPointsRate = newBasisPoints;\r\n' +
        '        maximumFee = newMaxFee.mul(10**decimals);\r\n' +
        '\r\n' +
        '        Params(basisPointsRate, maximumFee);\r\n' +
        '    }\r\n' +
        '\r\n' +
        '    // Called when new token are issued\r\n' +
        '    event Issue(uint amount);\r\n' +
        '\r\n' +
        '    // Called when tokens are redeemed\r\n' +
        '    event Redeem(uint amount);\r\n' +
        '\r\n' +
        '    // Called when contract is deprecated\r\n' +
        '    event Deprecate(address newAddress);\r\n' +
        '\r\n' +
        '    // Called if contract ever adds fees\r\n' +
        '    event Params(uint feeBasisPoints, uint maxFee);\r\n' +
        '}',
      ABI: '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_upgradedAddress","type":"address"}],"name":"deprecate","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"deprecated","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_evilUser","type":"address"}],"name":"addBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"upgradedAddress","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"balances","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"maximumFee","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"_totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"unpause","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_maker","type":"address"}],"name":"getBlackListStatus","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"},{"name":"","type":"address"}],"name":"allowed","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"paused","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"who","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[],"name":"pause","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"getOwner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"owner","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"newBasisPoints","type":"uint256"},{"name":"newMaxFee","type":"uint256"}],"name":"setParams","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"}],"name":"issue","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"amount","type":"uint256"}],"name":"redeem","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"basisPointsRate","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"isBlackListed","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_clearedUser","type":"address"}],"name":"removeBlackList","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"MAX_UINT","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_blackListedUser","type":"address"}],"name":"destroyBlackFunds","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"inputs":[{"name":"_initialSupply","type":"uint256"},{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_decimals","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"name":"amount","type":"uint256"}],"name":"Issue","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"amount","type":"uint256"}],"name":"Redeem","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"newAddress","type":"address"}],"name":"Deprecate","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"feeBasisPoints","type":"uint256"},{"indexed":false,"name":"maxFee","type":"uint256"}],"name":"Params","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_blackListedUser","type":"address"},{"indexed":false,"name":"_balance","type":"uint256"}],"name":"DestroyedBlackFunds","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_user","type":"address"}],"name":"AddedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"name":"_user","type":"address"}],"name":"RemovedBlackList","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[],"name":"Pause","type":"event"},{"anonymous":false,"inputs":[],"name":"Unpause","type":"event"}]',
      ContractName: 'TetherToken',
      CompilerVersion: 'v0.4.18+commit.9cf6e910',
      OptimizationUsed: '0',
      Runs: '0',
      ConstructorArguments: '000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a546574686572205553440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045553445400000000000000000000000000000000000000000000000000000000',
      EVMVersion: 'Default',
      Library: '',
      LicenseType: '',
      Proxy: '0',
      Implementation: '',
      SwarmSource: 'bzzr://645ee12d73db47fd78ba77fa1f824c3c8f9184061b3b10386beb4dc9236abb28'
    }
  ]
}
IncomingMessage {
  _readableState: ReadableState {
    objectMode: false,
    highWaterMark: 16384,
    buffer: BufferList { head: null, tail: null, length: 0 },
    length: 0,
    pipes: null,
    pipesCount: 0,
    flowing: true,
    ended: true,
    endEmitted: true,
    reading: false,
    sync: false,
    needReadable: false,
    emittedReadable: false,
    readableListening: false,
    resumeScheduled: false,
    emitClose: true,
    autoDestroy: false,
    destroyed: false,
    defaultEncoding: 'utf8',
    awaitDrainWriters: null,
    multiAwaitDrain: false,
    readingMore: false,
    decoder: null,
    encoding: null,
    [Symbol(kPaused)]: false
  },
  readable: false,
  _events: [Object: null prototype] {
    end: [ [Function: responseOnEnd], [Function] ],
    data: [Function],
    error: [Function]
  },
  _eventsCount: 3,
  _maxListeners: undefined,
  socket: TLSSocket {
    _tlsOptions: {
      allowHalfOpen: undefined,
      pipe: false,
      secureContext: [SecureContext],
      isServer: false,
      requestCert: true,
      rejectUnauthorized: true,
      session: undefined,
      ALPNProtocols: undefined,
      requestOCSP: undefined,
      enableTrace: undefined,
      pskCallback: undefined
    },
    _secureEstablished: true,
    _securePending: false,
    _newSessionPending: false,
    _controlReleased: true,
    secureConnecting: true,
    _SNICallback: null,
    servername: 'api.etherscan.io',
    alpnProtocol: false,
    authorized: true,
    authorizationError: null,
    encrypted: true,
    _events: [Object: null prototype] {
      close: [Array],
      end: [Function: onReadableStreamEnd],
      newListener: [Function: keylogNewListener],
      secure: [Function: onConnectSecure],
      session: [Function],
      free: [Function: onFree],
      timeout: [Function: onTimeout],
      agentRemove: [Function: onRemove],
      error: [Function: socketErrorListener],
      finish: [Function]
    },
    _eventsCount: 10,
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: 'api.etherscan.io',
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: false,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: true,
      decoder: null,
      encoding: null,
      [Symbol(kPaused)]: false
    },
    readable: true,
    _maxListeners: undefined,
    _writableState: WritableState {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: true,
      needDrain: false,
      ending: true,
      ended: true,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: 'utf8',
      length: 0,
      writing: false,
      corked: 0,
      sync: false,
      bufferProcessing: false,
      onwrite: [Function: bound onwrite],
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 1,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: [Object]
    },
    writable: false,
    allowHalfOpen: false,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: '',
    server: undefined,
    _server: null,
    ssl: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    _requestCert: true,
    _rejectUnauthorized: true,
    parser: null,
    _httpMessage: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      socket: [Circular],
      connection: [Circular],
      _header: 'GET /api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A HTTP/1.1\r\n' +
        'Host: api.etherscan.io\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _onPendingData: [Function: noopPendingOutput],
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      insecureHTTPParser: undefined,
      path: '/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _ended: true,
      res: [Circular],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    [Symbol(res)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(verified)]: true,
    [Symbol(pendingSession)]: null,
    [Symbol(asyncId)]: 6,
    [Symbol(kHandle)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(kSetNoDelay)]: false,
    [Symbol(lastWriteQueueSize)]: 0,
    [Symbol(timeout)]: null,
    [Symbol(kBuffer)]: null,
    [Symbol(kBufferCb)]: null,
    [Symbol(kBufferGen)]: null,
    [Symbol(kCapture)]: false,
    [Symbol(kBytesRead)]: 0,
    [Symbol(kBytesWritten)]: 0,
    [Symbol(connect-options)]: {
      rejectUnauthorized: true,
      ciphers: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
      checkServerIdentity: [Function: checkServerIdentity],
      minDHSize: 1024,
      maxRedirects: 21,
      maxBodyLength: 10485760,
      protocol: 'https:',
      port: 443,
      path: null,
      href: 'https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      method: 'GET',
      headers: {},
      nativeProtocols: [Object],
      hostname: 'api.etherscan.io',
      pathname: '/api',
      search: '?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _defaultAgent: [Agent],
      host: 'api.etherscan.io',
      servername: 'api.etherscan.io',
      _agentKey: 'api.etherscan.io:443::::::::::::::::::',
      encoding: null,
      singleUse: true
    }
  },
  connection: TLSSocket {
    _tlsOptions: {
      allowHalfOpen: undefined,
      pipe: false,
      secureContext: [SecureContext],
      isServer: false,
      requestCert: true,
      rejectUnauthorized: true,
      session: undefined,
      ALPNProtocols: undefined,
      requestOCSP: undefined,
      enableTrace: undefined,
      pskCallback: undefined
    },
    _secureEstablished: true,
    _securePending: false,
    _newSessionPending: false,
    _controlReleased: true,
    secureConnecting: true,
    _SNICallback: null,
    servername: 'api.etherscan.io',
    alpnProtocol: false,
    authorized: true,
    authorizationError: null,
    encrypted: true,
    _events: [Object: null prototype] {
      close: [Array],
      end: [Function: onReadableStreamEnd],
      newListener: [Function: keylogNewListener],
      secure: [Function: onConnectSecure],
      session: [Function],
      free: [Function: onFree],
      timeout: [Function: onTimeout],
      agentRemove: [Function: onRemove],
      error: [Function: socketErrorListener],
      finish: [Function]
    },
    _eventsCount: 10,
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: 'api.etherscan.io',
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: false,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: true,
      decoder: null,
      encoding: null,
      [Symbol(kPaused)]: false
    },
    readable: true,
    _maxListeners: undefined,
    _writableState: WritableState {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: true,
      needDrain: false,
      ending: true,
      ended: true,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: 'utf8',
      length: 0,
      writing: false,
      corked: 0,
      sync: false,
      bufferProcessing: false,
      onwrite: [Function: bound onwrite],
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 1,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: [Object]
    },
    writable: false,
    allowHalfOpen: false,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: '',
    server: undefined,
    _server: null,
    ssl: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    _requestCert: true,
    _rejectUnauthorized: true,
    parser: null,
    _httpMessage: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      socket: [Circular],
      connection: [Circular],
      _header: 'GET /api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A HTTP/1.1\r\n' +
        'Host: api.etherscan.io\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _onPendingData: [Function: noopPendingOutput],
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      insecureHTTPParser: undefined,
      path: '/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _ended: true,
      res: [Circular],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    [Symbol(res)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(verified)]: true,
    [Symbol(pendingSession)]: null,
    [Symbol(asyncId)]: 6,
    [Symbol(kHandle)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(kSetNoDelay)]: false,
    [Symbol(lastWriteQueueSize)]: 0,
    [Symbol(timeout)]: null,
    [Symbol(kBuffer)]: null,
    [Symbol(kBufferCb)]: null,
    [Symbol(kBufferGen)]: null,
    [Symbol(kCapture)]: false,
    [Symbol(kBytesRead)]: 0,
    [Symbol(kBytesWritten)]: 0,
    [Symbol(connect-options)]: {
      rejectUnauthorized: true,
      ciphers: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
      checkServerIdentity: [Function: checkServerIdentity],
      minDHSize: 1024,
      maxRedirects: 21,
      maxBodyLength: 10485760,
      protocol: 'https:',
      port: 443,
      path: null,
      href: 'https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      method: 'GET',
      headers: {},
      nativeProtocols: [Object],
      hostname: 'api.etherscan.io',
      pathname: '/api',
      search: '?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _defaultAgent: [Agent],
      host: 'api.etherscan.io',
      servername: 'api.etherscan.io',
      _agentKey: 'api.etherscan.io:443::::::::::::::::::',
      encoding: null,
      singleUse: true
    }
  },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: true,
  headers: {
    server: 'nginx',
    date: 'Mon, 14 Dec 2020 22:33:17 GMT',
    'content-type': 'application/json; charset=utf-8',
    'content-length': '25052',
    connection: 'close',
    'cache-control': 'private',
    'access-control-allow-origin': '*',
    'access-control-allow-headers': 'Content-Type',
    'access-control-allow-methods': 'GET, POST, OPTIONS',
    'x-frame-options': 'SAMEORIGIN'
  },
  rawHeaders: [
    'Server',
    'nginx',
    'Date',
    'Mon, 14 Dec 2020 22:33:17 GMT',
    'Content-Type',
    'application/json; charset=utf-8',
    'Content-Length',
    '25052',
    'Connection',
    'close',
    'Cache-Control',
    'private',
    'Access-Control-Allow-Origin',
    '*',
    'Access-Control-Allow-Headers',
    'Content-Type',
    'Access-Control-Allow-Methods',
    'GET, POST, OPTIONS',
    'X-Frame-Options',
    'SAMEORIGIN'
  ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url: '',
  method: null,
  statusCode: 200,
  statusMessage: 'OK',
  client: TLSSocket {
    _tlsOptions: {
      allowHalfOpen: undefined,
      pipe: false,
      secureContext: [SecureContext],
      isServer: false,
      requestCert: true,
      rejectUnauthorized: true,
      session: undefined,
      ALPNProtocols: undefined,
      requestOCSP: undefined,
      enableTrace: undefined,
      pskCallback: undefined
    },
    _secureEstablished: true,
    _securePending: false,
    _newSessionPending: false,
    _controlReleased: true,
    secureConnecting: true,
    _SNICallback: null,
    servername: 'api.etherscan.io',
    alpnProtocol: false,
    authorized: true,
    authorizationError: null,
    encrypted: true,
    _events: [Object: null prototype] {
      close: [Array],
      end: [Function: onReadableStreamEnd],
      newListener: [Function: keylogNewListener],
      secure: [Function: onConnectSecure],
      session: [Function],
      free: [Function: onFree],
      timeout: [Function: onTimeout],
      agentRemove: [Function: onRemove],
      error: [Function: socketErrorListener],
      finish: [Function]
    },
    _eventsCount: 10,
    connecting: false,
    _hadError: false,
    _parent: null,
    _host: 'api.etherscan.io',
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: null,
      pipesCount: 0,
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: false,
      sync: false,
      needReadable: true,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: false,
      emitClose: false,
      autoDestroy: false,
      destroyed: false,
      defaultEncoding: 'utf8',
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: true,
      decoder: null,
      encoding: null,
      [Symbol(kPaused)]: false
    },
    readable: true,
    _maxListeners: undefined,
    _writableState: WritableState {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: true,
      needDrain: false,
      ending: true,
      ended: true,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: 'utf8',
      length: 0,
      writing: false,
      corked: 0,
      sync: false,
      bufferProcessing: false,
      onwrite: [Function: bound onwrite],
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      bufferedRequest: null,
      lastBufferedRequest: null,
      pendingcb: 1,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: false,
      bufferedRequestCount: 0,
      corkedRequestsFree: [Object]
    },
    writable: false,
    allowHalfOpen: false,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: '',
    server: undefined,
    _server: null,
    ssl: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    _requestCert: true,
    _rejectUnauthorized: true,
    parser: null,
    _httpMessage: ClientRequest {
      _events: [Object: null prototype],
      _eventsCount: 7,
      _maxListeners: undefined,
      outputData: [],
      outputSize: 0,
      writable: true,
      _last: true,
      chunkedEncoding: false,
      shouldKeepAlive: false,
      useChunkedEncodingByDefault: false,
      sendDate: false,
      _removedConnection: false,
      _removedContLen: false,
      _removedTE: false,
      _contentLength: 0,
      _hasBody: true,
      _trailer: '',
      finished: true,
      _headerSent: true,
      socket: [Circular],
      connection: [Circular],
      _header: 'GET /api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A HTTP/1.1\r\n' +
        'Host: api.etherscan.io\r\n' +
        'Connection: close\r\n' +
        '\r\n',
      _onPendingData: [Function: noopPendingOutput],
      agent: [Agent],
      socketPath: undefined,
      method: 'GET',
      insecureHTTPParser: undefined,
      path: '/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _ended: true,
      res: [Circular],
      aborted: false,
      timeoutCb: null,
      upgradeOrConnect: false,
      parser: null,
      maxHeadersCount: null,
      reusedSocket: false,
      _redirectable: [Writable],
      [Symbol(kCapture)]: false,
      [Symbol(kNeedDrain)]: false,
      [Symbol(corked)]: 0,
      [Symbol(kOutHeaders)]: [Object: null prototype]
    },
    [Symbol(res)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(verified)]: true,
    [Symbol(pendingSession)]: null,
    [Symbol(asyncId)]: 6,
    [Symbol(kHandle)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: true,
      onkeylog: [Function: onkeylog],
      onhandshakestart: [Function: noop],
      onhandshakedone: [Function],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular]
    },
    [Symbol(kSetNoDelay)]: false,
    [Symbol(lastWriteQueueSize)]: 0,
    [Symbol(timeout)]: null,
    [Symbol(kBuffer)]: null,
    [Symbol(kBufferCb)]: null,
    [Symbol(kBufferGen)]: null,
    [Symbol(kCapture)]: false,
    [Symbol(kBytesRead)]: 0,
    [Symbol(kBytesWritten)]: 0,
    [Symbol(connect-options)]: {
      rejectUnauthorized: true,
      ciphers: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
      checkServerIdentity: [Function: checkServerIdentity],
      minDHSize: 1024,
      maxRedirects: 21,
      maxBodyLength: 10485760,
      protocol: 'https:',
      port: 443,
      path: null,
      href: 'https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      method: 'GET',
      headers: {},
      nativeProtocols: [Object],
      hostname: 'api.etherscan.io',
      pathname: '/api',
      search: '?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      _defaultAgent: [Agent],
      host: 'api.etherscan.io',
      servername: 'api.etherscan.io',
      _agentKey: 'api.etherscan.io:443::::::::::::::::::',
      encoding: null,
      singleUse: true
    }
  },
  _consuming: true,
  _dumped: false,
  req: ClientRequest {
    _events: [Object: null prototype] {
      socket: [Function],
      abort: [Function],
      aborted: [Function],
      connect: [Function],
      error: [Function],
      timeout: [Function],
      prefinish: [Function: requestOnPrefinish]
    },
    _eventsCount: 7,
    _maxListeners: undefined,
    outputData: [],
    outputSize: 0,
    writable: true,
    _last: true,
    chunkedEncoding: false,
    shouldKeepAlive: false,
    useChunkedEncodingByDefault: false,
    sendDate: false,
    _removedConnection: false,
    _removedContLen: false,
    _removedTE: false,
    _contentLength: 0,
    _hasBody: true,
    _trailer: '',
    finished: true,
    _headerSent: true,
    socket: TLSSocket {
      _tlsOptions: [Object],
      _secureEstablished: true,
      _securePending: false,
      _newSessionPending: false,
      _controlReleased: true,
      secureConnecting: true,
      _SNICallback: null,
      servername: 'api.etherscan.io',
      alpnProtocol: false,
      authorized: true,
      authorizationError: null,
      encrypted: true,
      _events: [Object: null prototype],
      _eventsCount: 10,
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: 'api.etherscan.io',
      _readableState: [ReadableState],
      readable: true,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: false,
      allowHalfOpen: false,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: undefined,
      _server: null,
      ssl: [TLSWrap],
      _requestCert: true,
      _rejectUnauthorized: true,
      parser: null,
      _httpMessage: [Circular],
      [Symbol(res)]: [TLSWrap],
      [Symbol(verified)]: true,
      [Symbol(pendingSession)]: null,
      [Symbol(asyncId)]: 6,
      [Symbol(kHandle)]: [TLSWrap],
      [Symbol(kSetNoDelay)]: false,
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: null,
      [Symbol(kBuffer)]: null,
      [Symbol(kBufferCb)]: null,
      [Symbol(kBufferGen)]: null,
      [Symbol(kCapture)]: false,
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0,
      [Symbol(connect-options)]: [Object]
    },
    connection: TLSSocket {
      _tlsOptions: [Object],
      _secureEstablished: true,
      _securePending: false,
      _newSessionPending: false,
      _controlReleased: true,
      secureConnecting: true,
      _SNICallback: null,
      servername: 'api.etherscan.io',
      alpnProtocol: false,
      authorized: true,
      authorizationError: null,
      encrypted: true,
      _events: [Object: null prototype],
      _eventsCount: 10,
      connecting: false,
      _hadError: false,
      _parent: null,
      _host: 'api.etherscan.io',
      _readableState: [ReadableState],
      readable: true,
      _maxListeners: undefined,
      _writableState: [WritableState],
      writable: false,
      allowHalfOpen: false,
      _sockname: null,
      _pendingData: null,
      _pendingEncoding: '',
      server: undefined,
      _server: null,
      ssl: [TLSWrap],
      _requestCert: true,
      _rejectUnauthorized: true,
      parser: null,
      _httpMessage: [Circular],
      [Symbol(res)]: [TLSWrap],
      [Symbol(verified)]: true,
      [Symbol(pendingSession)]: null,
      [Symbol(asyncId)]: 6,
      [Symbol(kHandle)]: [TLSWrap],
      [Symbol(kSetNoDelay)]: false,
      [Symbol(lastWriteQueueSize)]: 0,
      [Symbol(timeout)]: null,
      [Symbol(kBuffer)]: null,
      [Symbol(kBufferCb)]: null,
      [Symbol(kBufferGen)]: null,
      [Symbol(kCapture)]: false,
      [Symbol(kBytesRead)]: 0,
      [Symbol(kBytesWritten)]: 0,
      [Symbol(connect-options)]: [Object]
    },
    _header: 'GET /api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A HTTP/1.1\r\n' +
      'Host: api.etherscan.io\r\n' +
      'Connection: close\r\n' +
      '\r\n',
    _onPendingData: [Function: noopPendingOutput],
    agent: Agent {
      _events: [Object: null prototype],
      _eventsCount: 2,
      _maxListeners: undefined,
      defaultPort: 443,
      protocol: 'https:',
      options: [Object],
      requests: {},
      sockets: [Object],
      freeSockets: {},
      keepAliveMsecs: 1000,
      keepAlive: false,
      maxSockets: Infinity,
      maxFreeSockets: 256,
      maxCachedSessions: 100,
      _sessionCache: [Object],
      [Symbol(kCapture)]: false
    },
    socketPath: undefined,
    method: 'GET',
    insecureHTTPParser: undefined,
    path: '/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
    _ended: true,
    res: [Circular],
    aborted: false,
    timeoutCb: null,
    upgradeOrConnect: false,
    parser: null,
    maxHeadersCount: null,
    reusedSocket: false,
    _redirectable: Writable {
      _writableState: [WritableState],
      writable: true,
      _events: [Object: null prototype],
      _eventsCount: 2,
      _maxListeners: undefined,
      _options: [Object],
      _ended: true,
      _ending: true,
      _redirectCount: 0,
      _redirects: [],
      _requestBodyLength: 0,
      _requestBodyBuffers: [],
      _onNativeResponse: [Function],
      _currentRequest: [Circular],
      _currentUrl: 'https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
      [Symbol(kCapture)]: false
    },
    [Symbol(kCapture)]: false,
    [Symbol(kNeedDrain)]: false,
    [Symbol(corked)]: 0,
    [Symbol(kOutHeaders)]: [Object: null prototype] { host: [Array] }
  },
  responseUrl: 'https://api.etherscan.io/api?module=contract&action=getsourcecode&address=0xdac17f958d2ee523a2206206994597c13d831ec7&apikey=8TUK1TGEP6Z9MTMTKQYN97DPKNCR876B6A',
  redirects: [],
  [Symbol(kCapture)]: false
}
